This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-14T03:04:10.408Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
scripts/
  setup.sh
src/
  config/
    swagger.ts
  lib/
    logger/
    logger.test.ts
    logger.ts
  middleware/
    composable.integration.test.ts
    composable.test.ts
    composable.ts
    logger.ts
  routes/
    face-recognition.integration.test.ts
    face-recognition.ts
    health.integration.test.ts
    health.ts
  types/
    express.d.ts
    face-recognition.ts
  use-cases/
    face-recognition/
      index.test.ts
      index.ts
    health/
      index.test.ts
      index.ts
  app.ts
  index.ts
.eslintrc.json
.gitignore
.prettierrc
jest.config.js
package.json
README.md
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="scripts/setup.sh">
#!/bin/bash
# Create necessary directories
mkdir -p models storage/faces storage/gallery
# Download face-api.js models
MODELS_URL="https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights"
MODELS=(
  "ssd_mobilenetv1_model-weights_manifest.json"
  "ssd_mobilenetv1_model-shard1"
  "ssd_mobilenetv1_model-shard2"
  "face_landmark_68_model-weights_manifest.json"
  "face_landmark_68_model-shard1"
  "face_recognition_model-weights_manifest.json"
  "face_recognition_model-shard1"
  "face_recognition_model-shard2"
)
echo "Downloading face-api.js models..."
cd models
for model in "${MODELS[@]}"; do
  if [ ! -f "$model" ]; then
    echo "Downloading $model..."
    curl -L -O "$MODELS_URL/$model"
  else
    echo "$model already exists, skipping..."
  fi
done
cd ..
# Install dependencies
echo "Installing dependencies..."
npm install
# Create .env file if it doesn't exist
if [ ! -f .env ]; then
  echo "Creating .env file..."
  cp .env.sample .env
fi
# Make storage directories writable
chmod -R 755 storage
echo "Setup complete! ðŸŽ‰"
echo "Now you can:"
echo "1. Add face images to storage/faces/"
echo "2. Create albums in storage/gallery/"
echo "3. Add pictures to your albums in storage/gallery/<album-name>/"
echo "4. Start the API with: npm run dev"
</file>

<file path="src/config/swagger.ts">
import swaggerJsdoc from 'swagger-jsdoc';
const options: swaggerJsdoc.Options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Face Recognition API',
      version: '1.0.0',
      description: 'API for face recognition and matching in image albums',
    },
    servers: [
      {
        url: process.env.API_URL || 'http://localhost:3000',
        description: 'API Server',
      },
    ],
    components: {
      schemas: {
        FaceMatchRequest: {
          type: 'object',
          required: ['albumName', 'imagePath'],
          properties: {
            albumName: {
              type: 'string',
              description: 'Name of the album to search in',
            },
            imagePath: {
              type: 'string',
              description: 'Path to the target face image',
            },
          },
        },
        FaceMatchResponse: {
          type: 'object',
          properties: {
            matches: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  imagePath: {
                    type: 'string',
                    description: 'Path to the matched image',
                  },
                  similarity: {
                    type: 'number',
                    description: 'Similarity score (0-1)',
                  },
                },
              },
            },
          },
        },
        AlbumImagesRequest: {
          type: 'object',
          required: ['albumName'],
          properties: {
            albumName: {
              type: 'string',
              description: 'Name of the album to get images from',
            },
          },
        },
        AlbumImagesResponse: {
          type: 'object',
          properties: {
            images: {
              type: 'array',
              items: {
                type: 'string',
                description: 'Path to an image in the album',
              },
            },
          },
        },
        Error: {
          type: 'object',
          properties: {
            errors: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  message: {
                    type: 'string',
                    description: 'Error message',
                  },
                },
              },
            },
          },
        },
      },
    },
  },
  apis: ['./src/routes/*.ts'], // Path to the API routes
};
export const swaggerSpec = swaggerJsdoc(options);
</file>

<file path="src/lib/logger.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { Logger } from './logger';
describe('Logger', () => {
  const traceId = 'test-trace-id';
  let logger: Logger;
  const mockDate = new Date('2024-02-14T12:00:00.000Z');
  beforeEach(() => {
    vi.useFakeTimers();
    vi.setSystemTime(mockDate);
    logger = new Logger(traceId);
    vi.spyOn(console, 'debug');
    vi.spyOn(console, 'info');
    vi.spyOn(console, 'warn');
    vi.spyOn(console, 'error');
  });
  afterEach(() => {
    vi.useRealTimers();
    vi.restoreAllMocks();
  });
  it('should log debug messages with correct format', () => {
    const message = 'Debug message';
    const data = { key: 'value' };
    logger.debug(message, data);
    expect(console.debug).toHaveBeenCalledWith(
      `[${mockDate.toISOString()}] [${traceId}] [DEBUG] ${message} - "${JSON.stringify(data)}"`,
    );
  });
  it('should log info messages with correct format', () => {
    const message = 'Info message';
    logger.info(message);
    expect(console.info).toHaveBeenCalledWith(
      `[${mockDate.toISOString()}] [${traceId}] [INFO] ${message}`,
    );
  });
  it('should log warn messages with correct format', () => {
    const message = 'Warning message';
    const data = { warning: true };
    logger.warn(message, data);
    expect(console.warn).toHaveBeenCalledWith(
      `[${mockDate.toISOString()}] [${traceId}] [WARN] ${message} - "${JSON.stringify(data)}"`,
    );
  });
  it('should log error messages with correct format', () => {
    const message = 'Error message';
    const error = new Error('Test error');
    logger.error(message, error);
    expect(console.error).toHaveBeenCalledWith(
      `[${mockDate.toISOString()}] [${traceId}] [ERROR] ${message} - "${JSON.stringify(error)}"`,
    );
  });
  it('should validate log level using zod schema', () => {
    const message = 'Test message';
    expect(() => logger.debug(message)).not.toThrow();
    expect(() => logger.info(message)).not.toThrow();
    expect(() => logger.warn(message)).not.toThrow();
    expect(() => logger.error(message)).not.toThrow();
  });
});
</file>

<file path="src/lib/logger.ts">
import { z } from 'zod';
import { Request, Response, NextFunction, RequestHandler } from 'express';
import { randomUUID } from 'crypto';
// Logger level schema and type
export const LogLevelSchema = z.enum(['debug', 'info', 'warn', 'error']);
export type LogLevel = z.infer<typeof LogLevelSchema>;
// Log message schema and type
export const LogMessageSchema = z.object({
  level: LogLevelSchema,
  message: z.string(),
  traceId: z.string(),
  timestamp: z.string(),
  data: z.unknown().optional(),
});
export type LogMessage = z.infer<typeof LogMessageSchema>;
export class Logger {
  private traceId: string;
  constructor(traceId: string) {
    this.traceId = traceId;
  }
  private formatMessage(
    level: LogLevel,
    message: string,
    data?: unknown,
  ): LogMessage {
    return LogMessageSchema.parse({
      level,
      message,
      traceId: this.traceId,
      timestamp: new Date().toISOString(),
      data: data ? JSON.stringify(data) : undefined,
    });
  }
  private log(logMessage: LogMessage): void {
    const { level, message, traceId, timestamp, data } = logMessage;
    const formattedMessage = `[${timestamp}] [${traceId}] [${level.toUpperCase()}] ${message}${
      data ? ` - "${data}"` : ''
    }`;
    switch (level) {
      case 'debug':
        console.debug(formattedMessage);
        break;
      case 'info':
        console.info(formattedMessage);
        break;
      case 'warn':
        console.warn(formattedMessage);
        break;
      case 'error':
        console.error(formattedMessage);
        break;
    }
  }
  debug(message: string, data?: unknown): void {
    this.log(this.formatMessage('debug', message, data));
  }
  info(message: string, data?: unknown): void {
    this.log(this.formatMessage('info', message, data));
  }
  warn(message: string, data?: unknown): void {
    this.log(this.formatMessage('warn', message, data));
  }
  error(message: string, data?: unknown): void {
    this.log(this.formatMessage('error', message, data));
  }
}
export const loggerMiddleware: RequestHandler = (
  req: Request,
  _res: Response,
  next: NextFunction,
): void => {
  const traceId = randomUUID();
  const logger = new Logger(traceId);
  req.logger = logger;
  req.traceId = traceId;
  logger.info('Request started', {
    method: req.method,
    url: req.url,
    headers: req.headers,
    body: req.body,
  });
  next();
};
</file>

<file path="src/middleware/composable.integration.test.ts">
import express, { Request, Response } from 'express';
import request from 'supertest';
import { success, failure } from 'composable-functions';
import { withComposable } from './composable';
describe('Composable Middleware Integration', () => {
  const app = express();
  app.get(
    '/success',
    withComposable((_req: Request, _res: Response) =>
      Promise.resolve(success({ message: 'Success' })),
    ),
  );
  app.get(
    '/failure',
    withComposable((_req: Request, _res: Response) =>
      Promise.resolve(failure([new Error('Test error')])),
    ),
  );
  app.get(
    '/invalid',
    withComposable((_req: Request, _res: Response) =>
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Promise.resolve({ invalid: 'format' } as any),
    ),
  );
  app.get(
    '/error',
    withComposable((_req: Request, _res: Response) => {
      throw new Error('Unexpected error');
    }),
  );
  it('should handle successful responses', async () => {
    const response = await request(app).get('/success');
    expect(response.status).toBe(200);
    expect(response.body).toEqual({
      success: true,
      data: { message: 'Success' },
      errors: [],
    });
  });
  it('should handle failure responses with 500 status', async () => {
    const response = await request(app).get('/failure');
    expect(response.status).toBe(500);
    expect(response.body).toEqual({
      success: false,
      errors: [{ message: 'Test error' }],
    });
  });
  it('should handle invalid result format', async () => {
    const response = await request(app).get('/invalid');
    expect(response.status).toBe(500);
    expect(response.body).toEqual({
      success: false,
      errors: [{ message: 'Invalid composable result format' }],
    });
  });
  it('should handle thrown errors', async () => {
    const response = await request(app).get('/error');
    expect(response.status).toBe(500);
    expect(response.body).toEqual({
      message: 'Unexpected error',
    });
  });
});
</file>

<file path="src/middleware/composable.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { Request, Response } from 'express';
import { withComposable } from './composable';
import { success, failure } from 'composable-functions';
describe('withComposable', () => {
  const mockRequest = {} as Request;
  const mockResponse = {
    status: vi.fn().mockReturnThis(),
    json: vi.fn(),
  } as unknown as Response;
  const mockNext = vi.fn() as unknown as (err?: unknown) => void;
  beforeEach(() => {
    vi.clearAllMocks();
  });
  it('should handle successful results', async () => {
    const mockData = { foo: 'bar' };
    const handler = vi.fn().mockResolvedValue(success(mockData));
    const middleware = withComposable(handler);
    await middleware(mockRequest, mockResponse, mockNext);
    expect(mockResponse.json).toHaveBeenCalledWith({
      success: true,
      data: mockData,
      errors: [],
    });
  });
  it('should handle failure results with 500 status', async () => {
    const mockError = new Error('Test error');
    const handler = vi.fn().mockResolvedValue(failure([mockError]));
    const middleware = withComposable(handler);
    await middleware(mockRequest, mockResponse, mockNext);
    expect(mockResponse.status).toHaveBeenCalledWith(500);
    expect(mockResponse.json).toHaveBeenCalledWith({
      success: false,
      errors: [{ message: 'Test error' }],
    });
  });
  it('should handle invalid result format', async () => {
    const handler = vi.fn().mockResolvedValue({ invalid: 'format' });
    const middleware = withComposable(handler);
    await middleware(mockRequest, mockResponse, mockNext);
    expect(mockResponse.status).toHaveBeenCalledWith(500);
    expect(mockResponse.json).toHaveBeenCalledWith({
      success: false,
      errors: [{ message: 'Invalid composable result format' }],
    });
  });
  it('should handle thrown errors', async () => {
    const mockError = new Error('Test error');
    const handler = vi.fn().mockRejectedValue(mockError);
    const middleware = withComposable(handler);
    await middleware(mockRequest, mockResponse, mockNext);
    expect(mockResponse.status).toHaveBeenCalledWith(500);
    expect(mockResponse.json).toHaveBeenCalledWith({
      message: 'Test error',
    });
  });
});
</file>

<file path="src/middleware/composable.ts">
import { NextFunction, Request, Response } from 'express';
import type { Result } from 'composable-functions';
import { z } from 'zod';
export type ComposableRequestHandler<T = unknown> = (
  req: Request,
  res: Response,
) => Promise<Result<T>>;
export const ComposableResultSchema = z.discriminatedUnion('success', [
  z.object({
    success: z.literal(true),
    data: z.unknown(),
    errors: z.array(z.instanceof(Error)).optional(),
  }),
  z.object({
    success: z.literal(false),
    data: z.unknown().optional(),
    errors: z.array(z.instanceof(Error)),
  }),
]);
const serializeError = (error: Error): { message: string } => ({
  message: error.message,
});
export const withComposable = (handler: ComposableRequestHandler) => {
  return async (
    req: Request,
    res: Response,
    _next: NextFunction,
  ): Promise<void> => {
    try {
      const result = await handler(req, res);
      const validationResult = ComposableResultSchema.safeParse(result);
      if (!validationResult.success) {
        res.status(500).json({
          success: false,
          errors: [
            serializeError(new Error('Invalid composable result format')),
          ],
        });
        return;
      }
      if (!result.success) {
        res.status(500).json({
          ...result,
          errors: result.errors.map(serializeError),
        });
        return;
      }
      res.json({
        ...result,
        errors: result.errors?.map(serializeError) ?? [],
      });
    } catch (error) {
      if (error instanceof Error) {
        res.status(500).json(serializeError(error));
      } else {
        res.status(500).json({
          message: 'An unknown error occurred',
        });
      }
    }
  };
};
</file>

<file path="src/middleware/logger.ts">
import { Request, Response, NextFunction, RequestHandler } from 'express';
import { randomUUID } from 'crypto';
import { Logger } from '../lib/logger';
// Extend Express Request type using module augmentation
declare module 'express' {
  interface Request {
    logger: Logger;
    traceId: string;
  }
}
export const loggerMiddleware: RequestHandler = (
  req: Request,
  _res: Response,
  next: NextFunction,
): void => {
  const traceId = randomUUID();
  const logger = new Logger(traceId);
  req.logger = logger;
  req.traceId = traceId;
  logger.info('Request started', {
    method: req.method,
    url: req.url,
    headers: req.headers,
    body: req.body,
  });
  next();
};
</file>

<file path="src/routes/face-recognition.integration.test.ts">
import request from 'supertest';
import app from '../app';
import fs from 'fs/promises';
import path from 'path';
describe('Face Recognition API', () => {
  const testFacePath = 'test-face.jpg';
  const testAlbumName = 'test-album';
  const testAlbumPath = path.join('storage', 'gallery', testAlbumName);
  const testFaceStoragePath = path.join('storage', 'faces', testFacePath);
  beforeAll(async () => {
    // Create test directories
    await fs.mkdir(path.join('storage', 'faces'), { recursive: true });
    await fs.mkdir(testAlbumPath, { recursive: true });
    // Copy test images (you'll need to provide these)
    // await fs.copyFile(
    //   path.join('test', 'fixtures', 'face.jpg'),
    //   testFaceStoragePath
    // )
    // await fs.copyFile(
    //   path.join('test', 'fixtures', 'gallery-1.jpg'),
    //   path.join(testAlbumPath, 'image1.jpg')
    // )
  });
  afterAll(async () => {
    // Clean up test files
    try {
      await fs.unlink(testFaceStoragePath);
      await fs.rm(testAlbumPath, { recursive: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });
  describe('POST /face-recognition/match', () => {
    it('should return 400 if request body is invalid', async () => {
      const response = await request(app)
        .post('/face-recognition/match')
        .send({});
      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('error');
    });
    // Uncomment when you have test images
    // it('should find matching faces in the album', async () => {
    //   const response = await request(app)
    //     .post('/face-recognition/match')
    //     .send({
    //       albumName: testAlbumName,
    //       facePath: testFacePath,
    //     })
    //   expect(response.status).toBe(200)
    //   expect(response.body).toHaveProperty('matches')
    //   expect(Array.isArray(response.body.matches)).toBe(true)
    //   // If there are matches, verify their structure
    //   if (response.body.matches.length > 0) {
    //     const match = response.body.matches[0]
    //     expect(match).toHaveProperty('imagePath')
    //     expect(match).toHaveProperty('similarity')
    //     expect(match).toHaveProperty('boundingBox')
    //     expect(match.similarity).toBeGreaterThan(0.6)
    //   }
    // })
  });
  describe('GET /face-recognition/album/:albumName/images', () => {
    it('should return empty array for non-existent album', async () => {
      const response = await request(app)
        .get('/face-recognition/album/non-existent-album/images')
        .send();
      expect(response.status).toBe(200);
      expect(response.body).toEqual({ images: [] });
    });
    it('should return array of image paths for existing album', async () => {
      // Create test image in the album
      const testImagePath = path.join(testAlbumPath, 'test-image.jpg');
      await fs.writeFile(testImagePath, 'dummy image content');
      const response = await request(app)
        .get(`/face-recognition/album/${testAlbumName}/images`)
        .send();
      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('images');
      expect(Array.isArray(response.body.images)).toBe(true);
      expect(response.body.images).toContain(
        path.join('storage', 'gallery', testAlbumName, 'test-image.jpg'),
      );
      // Clean up test image
      await fs.unlink(testImagePath);
    });
  });
  describe('GET /face-recognition/image/:imagePath', () => {
    const testImagePath = path.join('storage', 'faces', 'test-image.jpg');
    beforeAll(async () => {
      // Create test image
      await fs.mkdir(path.dirname(testImagePath), { recursive: true });
      await fs.writeFile(testImagePath, 'dummy image content');
    });
    afterAll(async () => {
      // Clean up test image
      try {
        await fs.unlink(testImagePath);
      } catch (error) {
        // Ignore cleanup errors
      }
    });
    it('should return 400 for paths outside storage directory', async () => {
      const response = await request(app)
        .get('/face-recognition/image/../outside-storage.jpg')
        .send();
      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('error', 'Invalid image path');
    });
    it('should return 404 for non-existent images', async () => {
      const response = await request(app)
        .get('/face-recognition/image/storage/faces/non-existent.jpg')
        .send();
      expect(response.status).toBe(404);
    });
    it('should serve existing images', async () => {
      const response = await request(app)
        .get(`/face-recognition/image/${testImagePath}`)
        .send();
      expect(response.status).toBe(200);
      expect(response.type).toBe('image/jpeg');
      expect(response.body).toBeDefined();
    });
  });
});
</file>

<file path="src/routes/face-recognition.ts">
import { Router } from 'express';
import { findMatches, getAlbumImages } from '../use-cases/face-recognition';
import {
  FaceMatchRequestSchema,
  AlbumImagesRequestSchema,
  ImagePathRequestSchema,
} from '../types/face-recognition';
import path from 'path';
const router = Router();
/**
 * @openapi
 * /face-recognition/match:
 *   post:
 *     tags: [Face Recognition]
 *     summary: Find face matches in an album
 *     description: Finds faces in the specified album that match the target face image
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/FaceMatchRequest'
 *     responses:
 *       200:
 *         description: Successfully found matches
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/FaceMatchResponse'
 *       400:
 *         description: Invalid request
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       500:
 *         description: Server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
router.post('/match', async (req, res) => {
  const { logger } = req;
  try {
    logger.debug('Parsing face match request');
    const request = FaceMatchRequestSchema.parse(req.body);
    logger.info('Processing face match request', { request });
    const result = await findMatches(request, { logger });
    if (!result.success) {
      const errorMessage = result.errors.map((e) => e.message).join(', ');
      logger.warn('Face match request failed validation', {
        errors: result.errors,
      });
      return res.status(400).json({ error: errorMessage });
    }
    logger.info('Face match request successful', { result: result.data });
    res.json(result.data);
  } catch (error) {
    if (error instanceof Error) {
      logger.error('Face match request failed', { error });
      res.status(400).json({ error: error.message });
    } else {
      logger.error('Internal server error', { error });
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});
/**
 * @openapi
 * /face-recognition/album/{albumName}/images:
 *   get:
 *     tags: [Face Recognition]
 *     summary: Get all images in an album by name
 *     description: Returns a list of all image paths in the specified album
 *     parameters:
 *       - in: path
 *         name: albumName
 *         required: true
 *         schema:
 *           type: string
 *         description: Name of the album to get images from
 *     responses:
 *       200:
 *         description: Successfully retrieved album images
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AlbumImagesResponse'
 *       400:
 *         description: Invalid request
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       500:
 *         description: Server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
router.get('/album/:albumName/images', async (req, res) => {
  const { logger } = req;
  try {
    logger.debug('Parsing album images request');
    const request = AlbumImagesRequestSchema.parse({
      albumName: req.params.albumName,
    });
    logger.info('Processing album images request', { request });
    const result = await getAlbumImages(request, { logger });
    if (!result.success) {
      logger.warn('Album images request failed validation', {
        errors: result.errors,
      });
      if (result.errors[0]?.message === 'Unexpected error') {
        return res.status(400).json({ error: result.errors[0].message });
      }
      return res.json({ images: [] });
    }
    logger.info('Album images request successful', { result: result.data });
    res.json(result.data);
  } catch (error) {
    if (error instanceof Error) {
      logger.error('Album images request failed', { error });
      res.status(400).json({ error: error.message });
    } else {
      logger.error('Internal server error', { error });
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});
/**
 * @openapi
 * /face-recognition/image/{imagePath}:
 *   get:
 *     tags: [Face Recognition]
 *     summary: Get an image by path
 *     description: Returns the image file at the specified path
 *     parameters:
 *       - in: path
 *         name: imagePath
 *         required: true
 *         schema:
 *           type: string
 *         description: Path to the image file
 *     responses:
 *       200:
 *         description: Successfully retrieved image
 *         content:
 *           image/*:
 *             schema:
 *               type: string
 *               format: binary
 *       400:
 *         description: Invalid request
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 *       500:
 *         description: Server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Error'
 */
router.get('/image/:imagePath(*)', async (req, res) => {
  const { logger } = req;
  try {
    logger.debug('Parsing image path request');
    const request = ImagePathRequestSchema.parse({
      imagePath: req.params.imagePath,
    });
    logger.info('Processing image request', { request });
    // Validate that the path is within our storage directory
    const fullPath = path.join(process.cwd(), request.imagePath);
    if (!fullPath.startsWith(path.join(process.cwd(), 'storage'))) {
      logger.warn('Invalid image path - outside storage directory', {
        fullPath,
      });
      return res.status(400).json({ error: 'Invalid image path' });
    }
    // Send the file
    logger.info('Sending image file', { path: fullPath });
    res.sendFile(fullPath);
  } catch (error) {
    if (error instanceof Error) {
      logger.error('Image request failed', { error });
      res.status(400).json({ error: error.message });
    } else {
      logger.error('Internal server error', { error });
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});
export default router;
</file>

<file path="src/routes/health.integration.test.ts">
import request from 'supertest';
import app from '../app';
describe('Health Check Endpoint', () => {
  it('should return a valid health check response', async () => {
    const response = await request(app).get('/health');
    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(response.body.data.status).toBe('ok');
    expect(new Date(response.body.data.timestamp)).toBeInstanceOf(Date);
  });
});
</file>

<file path="src/routes/health.ts">
import { Router } from 'express';
import { withComposable } from '../middleware/composable';
import { getHealthCheck } from '../use-cases/health';
const router = Router();
/**
 * @openapi
 * /health:
 *   get:
 *     tags: [Health]
 *     summary: Health check endpoint
 *     description: Returns the health status of the API
 *     responses:
 *       200:
 *         description: API is healthy
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: ok
 */
router.get(
  '/',
  withComposable((_req, _res) => getHealthCheck()),
);
export default router;
</file>

<file path="src/types/express.d.ts">
import { Logger } from '../lib/logger';
declare module 'express-serve-static-core' {
  interface Request {
    logger: Logger;
    traceId: string;
  }
}
</file>

<file path="src/types/face-recognition.ts">
import { z } from 'zod';
export const FaceMatchRequestSchema = z.object({
  albumName: z.string().min(1),
  facePath: z.string().min(1),
});
export type FaceMatchRequest = z.infer<typeof FaceMatchRequestSchema>;
export const FaceMatchResultSchema = z.object({
  imagePath: z.string(),
  similarity: z.number(),
  boundingBox: z.object({
    x: z.number(),
    y: z.number(),
    width: z.number(),
    height: z.number(),
  }),
});
export type FaceMatchResult = z.infer<typeof FaceMatchResultSchema>;
export const FaceMatchResponseSchema = z.object({
  matches: z.array(FaceMatchResultSchema),
});
export type FaceMatchResponse = z.infer<typeof FaceMatchResponseSchema>;
export const AlbumImagesRequestSchema = z.object({
  albumName: z.string().min(1),
});
export type AlbumImagesRequest = z.infer<typeof AlbumImagesRequestSchema>;
export const AlbumImagesResponseSchema = z.object({
  images: z.array(z.string()),
});
export type AlbumImagesResponse = z.infer<typeof AlbumImagesResponseSchema>;
export const ImagePathRequestSchema = z.object({
  imagePath: z.string().min(1),
});
export type ImagePathRequest = z.infer<typeof ImagePathRequestSchema>;
</file>

<file path="src/use-cases/face-recognition/index.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { findMatches, getAlbumImages } from '.';
import * as faceapi from 'face-api.js';
import fs from 'fs/promises';
import { Dirent } from 'fs';
import { success } from 'composable-functions';
import { Logger } from '../../lib/logger';
// Create a mock logger for testing
const createMockLogger = (): Pick<
  Logger,
  'debug' | 'info' | 'warn' | 'error'
> => ({
  debug: vi.fn(),
  info: vi.fn(),
  warn: vi.fn(),
  error: vi.fn(),
});
// Mock dependencies
vi.mock('face-api.js', () => ({
  env: {
    monkeyPatch: vi.fn(),
  },
  nets: {
    ssdMobilenetv1: {
      loadFromDisk: vi.fn(),
    },
    faceLandmark68Net: {
      loadFromDisk: vi.fn(),
    },
    faceRecognitionNet: {
      loadFromDisk: vi.fn(),
    },
  },
  detectSingleFace: vi.fn(),
  euclideanDistance: vi.fn(),
}));
// Mock canvas with all required exports
vi.mock('canvas', () => {
  const mockContext = {
    drawImage: vi.fn(),
  };
  const mockCanvas = {
    getContext: vi.fn(() => mockContext),
    width: 800,
    height: 600,
  };
  return {
    createCanvas: vi.fn(() => mockCanvas),
    loadImage: vi.fn(() => ({
      width: 800,
      height: 600,
    })),
    Canvas: class {
      getContext(): typeof mockContext {
        return mockContext;
      }
    },
    Image: class {},
    ImageData: class {},
  };
});
vi.mock('fs/promises');
describe('Face Recognition Use Case', () => {
  let mockLogger: ReturnType<typeof createMockLogger>;
  beforeEach(() => {
    vi.clearAllMocks();
    mockLogger = createMockLogger();
  });
  it('should return empty matches when no faces are found', async () => {
    // Mock file system
    const mockDirents = [
      { name: 'image1.jpg', isFile: () => true } as Dirent,
      { name: 'image2.jpg', isFile: () => true } as Dirent,
    ];
    vi.mocked(fs.readdir).mockResolvedValue(mockDirents);
    // Mock face detection to return null (no face found)
    const mockDetectSingleFace = {
      withFaceLandmarks: vi.fn().mockReturnThis(),
      withFaceDescriptor: vi.fn().mockResolvedValue(null),
    };
    vi.mocked(faceapi.detectSingleFace).mockReturnValue(
      mockDetectSingleFace as unknown as ReturnType<
        typeof faceapi.detectSingleFace
      >,
    );
    const result = await findMatches(
      {
        albumName: 'test-album',
        facePath: 'test-face.jpg',
      },
      { logger: mockLogger as unknown as Logger },
    );
    expect(result).toEqual(success({ matches: [] }));
    expect(mockLogger.info).toHaveBeenCalledWith(
      'No face found in target image',
    );
  });
  it('should return matches when faces are found', async () => {
    // Mock file system first
    vi.mocked(fs.readdir).mockResolvedValue([
      { name: 'image1.jpg', isFile: () => true } as Dirent,
    ]);
    // Mock face detection with successful matches
    const mockDetection = {
      descriptor: new Float32Array(128),
      detection: {
        box: {
          x: 0,
          y: 0,
          width: 100,
          height: 100,
        },
      },
      landmarks: {},
    };
    // Create a mock that always returns a successful detection
    const mockWithFaceDescriptor = vi.fn().mockResolvedValue(mockDetection);
    const mockWithFaceLandmarks = vi
      .fn()
      .mockReturnValue({ withFaceDescriptor: mockWithFaceDescriptor });
    const mockDetectSingleFace = { withFaceLandmarks: mockWithFaceLandmarks };
    // Mock detectSingleFace to always return the same mock
    vi.mocked(faceapi.detectSingleFace).mockImplementation(() => {
      mockLogger.debug('Face detection started');
      return mockDetectSingleFace as unknown as ReturnType<
        typeof faceapi.detectSingleFace
      >;
    });
    // Mock distance calculation to return a good match
    vi.mocked(faceapi.euclideanDistance).mockImplementation((desc1, desc2) => {
      mockLogger.debug('Calculating face similarity', { desc1, desc2 });
      return 0.3; // 1 - 0.3 = 0.7 similarity
    });
    const result = await findMatches(
      {
        albumName: 'test-album',
        facePath: 'test-face.jpg',
      },
      { logger: mockLogger as unknown as Logger },
    );
    mockLogger.info('Test completed', { result });
    expect(result).toEqual(
      success({
        matches: [
          {
            imagePath: expect.stringContaining('image1.jpg'),
            similarity: 0.7,
            boundingBox: {
              x: 0,
              y: 0,
              width: 100,
              height: 100,
            },
          },
        ],
      }),
    );
    // Verify that the mocks were called correctly
    expect(faceapi.detectSingleFace).toHaveBeenCalledTimes(2); // Once for target face, once for gallery image
    expect(mockWithFaceLandmarks).toHaveBeenCalledTimes(2);
    expect(mockWithFaceDescriptor).toHaveBeenCalledTimes(2);
    expect(faceapi.euclideanDistance).toHaveBeenCalledTimes(1);
    expect(mockLogger.info).toHaveBeenCalledWith('Test completed', { result });
  });
  describe('getAlbumImages', () => {
    it('should return empty array when album does not exist', async () => {
      // Mock readdir to throw ENOENT error
      vi.mocked(fs.readdir).mockRejectedValue(
        Object.assign(new Error(), { code: 'ENOENT' }),
      );
      const result = await getAlbumImages(
        { albumName: 'non-existent-album' },
        { logger: mockLogger as unknown as Logger },
      );
      expect(result).toEqual(success({ images: [] }));
      expect(mockLogger.warn).toHaveBeenCalledWith('Album not found', {
        albumName: 'non-existent-album',
      });
    });
    it('should return array of image paths for existing album', async () => {
      // Mock file system
      const mockDirents = [
        { name: 'image1.jpg', isFile: () => true } as Dirent,
        { name: 'image2.png', isFile: () => true } as Dirent,
        { name: 'not-an-image.txt', isFile: () => true } as Dirent,
      ];
      vi.mocked(fs.readdir).mockResolvedValue(mockDirents);
      const result = await getAlbumImages(
        { albumName: 'test-album' },
        { logger: mockLogger as unknown as Logger },
      );
      expect(result).toEqual(
        success({
          images: [
            'storage/gallery/test-album/image1.jpg',
            'storage/gallery/test-album/image2.png',
          ],
        }),
      );
      expect(mockLogger.info).toHaveBeenCalledWith(
        'Successfully retrieved album images',
        { count: 2 },
      );
    });
    it('should return failure for unexpected errors', async () => {
      // Mock readdir to throw unexpected error
      const error = new Error('Unexpected error');
      vi.mocked(fs.readdir).mockRejectedValue(error);
      const result = await getAlbumImages(
        { albumName: 'test-album' },
        { logger: mockLogger as unknown as Logger },
      );
      expect(result.success).toBe(false);
      expect(result.errors[0].message).toBe('Unexpected error');
    });
  });
});
</file>

<file path="src/use-cases/face-recognition/index.ts">
import * as faceapi from 'face-api.js';
import { createCanvas, loadImage, Canvas, Image, ImageData } from 'canvas';
import { composable } from 'composable-functions';
import { readdir } from 'fs/promises';
import { Dirent } from 'fs';
import path from 'path';
import {
  FaceMatchRequest,
  AlbumImagesRequest,
} from '../../types/face-recognition';
import { Logger } from '../../lib/logger';
// Monkey patch the faceapi canvas with type assertions for Node's canvas implementation
faceapi.env.monkeyPatch({
  Canvas: Canvas as unknown as typeof HTMLCanvasElement,
  Image: Image as unknown as typeof HTMLImageElement,
  ImageData: ImageData as unknown as typeof globalThis.ImageData,
});
// Load models on startup
let modelsLoaded = false;
const loadModels = async (): Promise<void> => {
  if (modelsLoaded) return;
  await faceapi.nets.ssdMobilenetv1.loadFromDisk('models');
  await faceapi.nets.faceLandmark68Net.loadFromDisk('models');
  await faceapi.nets.faceRecognitionNet.loadFromDisk('models');
  modelsLoaded = true;
};
// Get similarity threshold from environment variable or use default
const similarityThreshold = parseFloat(
  process.env.FACE_SIMILARITY_THRESHOLD || '0.4',
);
const getFaceDescriptor = async (
  imagePath: string,
  dependencies: {
    logger: Logger;
  },
): Promise<faceapi.WithFaceDescriptor<
  faceapi.WithFaceLandmarks<{ detection: faceapi.FaceDetection }>
> | null> => {
  const { logger } = dependencies;
  await loadModels();
  const img = await loadImage(imagePath);
  const canvas = createCanvas(img.width, img.height);
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  logger.debug(`Getting face descriptor for ${imagePath}`);
  const detection = await faceapi
    .detectSingleFace(canvas as unknown as HTMLCanvasElement)
    .withFaceLandmarks()
    .withFaceDescriptor();
  logger.debug(`Face detection result for ${imagePath}:`, { detection });
  return detection || null;
};
export const findMatches = composable(
  async (
    request: FaceMatchRequest,
    dependencies: {
      logger: Logger;
    },
  ) => {
    const { albumName, facePath } = request;
    const { logger } = dependencies;
    const faceImagePath = path.join('storage', 'faces', facePath);
    const galleryPath = path.join('storage', 'gallery', albumName);
    // Get face descriptor for the target face
    logger.debug('Getting target face descriptor...');
    logger.debug('similarityThreshold: ', similarityThreshold);
    const targetFace = await getFaceDescriptor(faceImagePath, { logger });
    if (!targetFace) {
      logger.info('No face found in target image');
      return { matches: [] };
    }
    logger.debug('Target face descriptor:', {
      descriptor: targetFace.descriptor,
    });
    // Get all images from the gallery
    const files = await readdir(galleryPath, { withFileTypes: true });
    logger.debug('Raw files from readdir:', { files });
    const imageFiles = files.filter((file: Dirent) => {
      const isImage = /\.(jpg|jpeg|png)$/i.test(file.name);
      logger.debug(`File ${file.name} is image: ${isImage}`);
      return isImage;
    });
    logger.debug('Filtered image files:', { imageFiles });
    // Process each gallery image
    const matches = [];
    for (const file of imageFiles) {
      const imagePath = path.join(galleryPath, file.name);
      logger.debug(`Processing gallery image: ${imagePath}`);
      try {
        const detection = await getFaceDescriptor(imagePath, { logger });
        if (!detection) {
          logger.info(`No face found in gallery image: ${imagePath}`);
          continue;
        }
        logger.debug(`Found face in gallery image: ${imagePath}`);
        // Calculate similarity
        const distance = faceapi.euclideanDistance(
          targetFace.descriptor,
          detection.descriptor,
        );
        const similarity = 1 - distance;
        logger.debug(`Similarity for ${imagePath}: ${similarity}`);
        // Only include matches above threshold
        if (similarity > similarityThreshold) {
          logger.info(`Adding match: ${imagePath} (similarity: ${similarity})`);
          matches.push({
            imagePath: path.relative(process.cwd(), imagePath),
            similarity,
            boundingBox: {
              x: detection.detection.box.x,
              y: detection.detection.box.y,
              width: detection.detection.box.width,
              height: detection.detection.box.height,
            },
          });
        }
      } catch (error) {
        if (error instanceof Error) {
          logger.warn(`Skipping ${file.name}: ${error.message}`);
        }
        continue;
      }
    }
    // Sort matches by similarity (highest first)
    matches.sort((a, b) => b.similarity - a.similarity);
    logger.info('Final matches:', { matches });
    return {
      matches,
    };
  },
);
export const getAlbumImages = composable(
  async (request: AlbumImagesRequest, dependencies: { logger: Logger }) => {
    const { albumName } = request;
    const { logger } = dependencies;
    const galleryPath = path.join('storage', 'gallery', albumName);
    logger.debug('Getting images from album', { albumName });
    try {
      // Get all images from the gallery
      const files = await readdir(galleryPath, { withFileTypes: true });
      logger.debug('Raw files from readdir:', { files });
      const imageFiles = files.filter((file: Dirent) => {
        const isImage = /\.(jpg|jpeg|png)$/i.test(file.name);
        logger.debug(`File ${file.name} is image: ${isImage}`);
        return isImage;
      });
      logger.debug('Filtered image files:', { imageFiles });
      // Map to relative paths
      const images = imageFiles.map((file) =>
        path.relative(process.cwd(), path.join(galleryPath, file.name)),
      );
      logger.info('Successfully retrieved album images', {
        count: images.length,
      });
      return { images };
    } catch (error) {
      if (
        error instanceof Error &&
        'code' in error &&
        error.code === 'ENOENT'
      ) {
        logger.warn('Album not found', { albumName });
        return { images: [] };
      }
      throw error;
    }
  },
);
</file>

<file path="src/use-cases/health/index.test.ts">
import { describe, it, expect } from 'vitest';
import { getHealthCheck } from './index';
describe('getHealthCheck', () => {
  it('should return a valid health check response', async () => {
    const result = await getHealthCheck();
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.status).toBe('ok');
      expect(new Date(result.data.timestamp)).toBeInstanceOf(Date);
    }
  });
});
</file>

<file path="src/use-cases/health/index.ts">
import { composable } from 'composable-functions';
export const getHealthCheck = composable(
  () =>
    ({
      status: 'ok',
      timestamp: new Date().toISOString(),
    }) as const,
);
</file>

<file path="src/app.ts">
import express from 'express';
import swaggerUi from 'swagger-ui-express';
import { swaggerSpec } from './config/swagger';
import { loggerMiddleware } from './middleware/logger';
import healthRouter from './routes/health';
import faceRecognitionRouter from './routes/face-recognition';
const app = express();
app.use(express.json());
app.use(loggerMiddleware);
// API Documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
// Routes
app.use('/health', healthRouter);
app.use('/face-recognition', faceRecognitionRouter);
export default app;
</file>

<file path="src/index.ts">
import app from './app';
import { config } from 'dotenv';
import { Logger } from './lib/logger';
import { randomUUID } from 'crypto';
config();
const port = process.env.PORT || 3000;
// Create a logger instance for server startup
const serverLogger = new Logger(randomUUID());
app.listen(port, () => {
  serverLogger.info('Server started', { port });
});
</file>

<file path=".eslintrc.json">
{
  "env": {
    "node": true,
    "es2022": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "prettier/prettier": "error",
    "@typescript-eslint/explicit-function-return-type": "error",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "@typescript-eslint/no-explicit-any": "error"
  }
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/
.pnp/
.pnp.js

# Build
dist/
build/

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE
.idea/
.vscode/
*.swp
*.swo

# Testing
coverage/

# OS
.DS_Store
Thumbs.db 

# Local research for cursor-tools
research/

# Storage
storage/faces/*
!storage/faces/.gitkeep
storage/gallery/*
!storage/gallery/.gitkeep

# Models
models/*
!models/.gitkeep
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2
}
</file>

<file path="jest.config.js">
export default {
  preset: 'ts-jest',
  testEnvironment: 'node',
  extensionsToTreatAsEsm: ['.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  testMatch: ['**/*.integration.test.ts'],
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
      },
    ],
  },
  moduleDirectories: ['node_modules', 'src'],
};
</file>

<file path="package.json">
{
  "name": "face-recognition-api",
  "version": "1.0.0",
  "description": "A RESTful API for face recognition",
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "vitest run",
    "test:watch": "vitest watch",
    "test:integration": "jest --config jest.config.js",
    "format": "prettier --write \"src/**/*.ts\"",
    "lint": "eslint \"src/**/*.ts\" --fix",
    "prepare": "husky"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.7",
    "canvas": "^3.1.0",
    "composable-functions": "^4.5.0",
    "dotenv": "^16.4.1",
    "express": "^4.18.2",
    "face-api.js": "^0.22.2",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.11",
    "@types/node": "^20.11.16",
    "@types/supertest": "^6.0.2",
    "@typescript-eslint/eslint-plugin": "^6.20.0",
    "@typescript-eslint/parser": "^6.20.0",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "husky": "^9.0.7",
    "jest": "^29.7.0",
    "openapi-types": "^12.1.3",
    "prettier": "^3.2.4",
    "supertest": "^6.3.4",
    "ts-jest": "^29.1.2",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3",
    "vitest": "^1.2.2"
  }
}
</file>

<file path="README.md">
# Face Recognition API

A REST API for face recognition in images using face-api.js.

## Features

- Face detection and recognition using face-api.js
- Search for matching faces in image albums
- Type-safe API with Zod validation
- Composable and testable architecture
- Integration and unit tests

## Prerequisites

- Node.js 18 or higher
- npm or yarn

## Setup

1. Clone the repository:

```bash
git clone https://github.com/yourusername/face-recognition-api.git
cd face-recognition-api
```

2. Install dependencies:

```bash
npm install
```

3. Run the setup script to download face-api.js models and create necessary directories:

```bash
chmod +x scripts/setup.sh
./scripts/setup.sh
```

4. Create a `.env` file:

```bash
cp .env.sample .env
```

5. Add your face images:

- Put face images to search for in `storage/faces/`
- Create albums in `storage/gallery/`
- Add pictures to search through in `storage/gallery/<album-name>/`

## Development

Start the development server:

```bash
npm run dev
```

Run tests:

```bash
npm test
```

Run linter:

```bash
npm run lint
```

Format code:

```bash
npm run format
```

## API Endpoints

### POST /face-recognition/match

Search for matching faces in an album.

**Request Body:**

```json
{
  "albumName": "my-album",
  "facePath": "person.jpg"
}
```

**Response:**

```json
{
  "matches": [
    {
      "imagePath": "storage/gallery/my-album/photo1.jpg",
      "similarity": 0.92,
      "boundingBox": {
        "x": 100,
        "y": 50,
        "width": 200,
        "height": 200
      }
    }
  ]
}
```

## Project Structure

- `src/` - Source code
  - `types/` - TypeScript types and Zod schemas
  - `routes/` - Express route handlers
  - `use-cases/` - Business logic
  - `middleware/` - Express middleware
- `storage/` - Image storage
  - `faces/` - Face images to search for
  - `gallery/` - Albums of images to search through
- `models/` - face-api.js model files
- `scripts/` - Setup and utility scripts

## Contributing

1. Create a feature branch
2. Make your changes
3. Run tests and linting
4. Create a pull request

## License

MIT
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import path from 'path';
export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    exclude: ['**/*.integration.test.ts', 'node_modules'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
</file>

</files>
