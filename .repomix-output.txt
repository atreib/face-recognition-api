This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-14T00:56:35.128Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
research/
  repo-summary.md
src/
  middleware/
    composable.integration.test.ts
    composable.test.ts
    composable.ts
  routes/
    health.integration.test.ts
    health.ts
  use-cases/
    health/
      index.test.ts
      index.ts
  app.ts
  index.ts
.eslintrc.json
.gitignore
.prettierrc
jest.config.js
package.json
README.md
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="research/repo-summary.md">
Packing repository using repomix...
</file>

<file path="src/middleware/composable.integration.test.ts">
import express, { Request, Response } from 'express';
import request from 'supertest';
import { success, failure } from 'composable-functions';
import { withComposable } from './composable';
describe('Composable Middleware Integration', () => {
  const app = express();
  app.get(
    '/success',
    withComposable((_req: Request, _res: Response) =>
      Promise.resolve(success({ message: 'Success' })),
    ),
  );
  app.get(
    '/failure',
    withComposable((_req: Request, _res: Response) =>
      Promise.resolve(failure([new Error('Test error')])),
    ),
  );
  app.get(
    '/invalid',
    withComposable((_req: Request, _res: Response) =>
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Promise.resolve({ invalid: 'format' } as any),
    ),
  );
  app.get(
    '/error',
    withComposable((_req: Request, _res: Response) => {
      throw new Error('Unexpected error');
    }),
  );
  it('should handle successful responses', async () => {
    const response = await request(app).get('/success');
    expect(response.status).toBe(200);
    expect(response.body).toEqual({
      success: true,
      data: { message: 'Success' },
      errors: [],
    });
  });
  it('should handle failure responses with 500 status', async () => {
    const response = await request(app).get('/failure');
    expect(response.status).toBe(500);
    expect(response.body).toEqual({
      success: false,
      errors: [{ message: 'Test error' }],
    });
  });
  it('should handle invalid result format', async () => {
    const response = await request(app).get('/invalid');
    expect(response.status).toBe(500);
    expect(response.body).toEqual({
      success: false,
      errors: [{ message: 'Invalid composable result format' }],
    });
  });
  it('should handle thrown errors', async () => {
    const response = await request(app).get('/error');
    expect(response.status).toBe(500);
    expect(response.body).toEqual({
      message: 'Unexpected error',
    });
  });
});
</file>

<file path="src/middleware/composable.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { Request, Response } from 'express';
import { withComposable } from './composable';
import { success, failure } from 'composable-functions';
describe('withComposable', () => {
  const mockRequest = {} as Request;
  const mockResponse = {
    status: vi.fn().mockReturnThis(),
    json: vi.fn(),
  } as unknown as Response;
  const mockNext = vi.fn() as unknown as (err?: unknown) => void;
  beforeEach(() => {
    vi.clearAllMocks();
  });
  it('should handle successful results', async () => {
    const mockData = { foo: 'bar' };
    const handler = vi.fn().mockResolvedValue(success(mockData));
    const middleware = withComposable(handler);
    await middleware(mockRequest, mockResponse, mockNext);
    expect(mockResponse.json).toHaveBeenCalledWith({
      success: true,
      data: mockData,
      errors: [],
    });
  });
  it('should handle failure results with 500 status', async () => {
    const mockError = new Error('Test error');
    const handler = vi.fn().mockResolvedValue(failure([mockError]));
    const middleware = withComposable(handler);
    await middleware(mockRequest, mockResponse, mockNext);
    expect(mockResponse.status).toHaveBeenCalledWith(500);
    expect(mockResponse.json).toHaveBeenCalledWith({
      success: false,
      errors: [{ message: 'Test error' }],
    });
  });
  it('should handle invalid result format', async () => {
    const handler = vi.fn().mockResolvedValue({ invalid: 'format' });
    const middleware = withComposable(handler);
    await middleware(mockRequest, mockResponse, mockNext);
    expect(mockResponse.status).toHaveBeenCalledWith(500);
    expect(mockResponse.json).toHaveBeenCalledWith({
      success: false,
      errors: [{ message: 'Invalid composable result format' }],
    });
  });
  it('should handle thrown errors', async () => {
    const mockError = new Error('Test error');
    const handler = vi.fn().mockRejectedValue(mockError);
    const middleware = withComposable(handler);
    await middleware(mockRequest, mockResponse, mockNext);
    expect(mockResponse.status).toHaveBeenCalledWith(500);
    expect(mockResponse.json).toHaveBeenCalledWith({
      message: 'Test error',
    });
  });
});
</file>

<file path="src/middleware/composable.ts">
import { NextFunction, Request, Response } from 'express';
import type { Result } from 'composable-functions';
import { z } from 'zod';
export type ComposableRequestHandler<T = unknown> = (
  req: Request,
  res: Response,
) => Promise<Result<T>>;
export const ComposableResultSchema = z.discriminatedUnion('success', [
  z.object({
    success: z.literal(true),
    data: z.unknown(),
    errors: z.array(z.instanceof(Error)).optional(),
  }),
  z.object({
    success: z.literal(false),
    data: z.unknown().optional(),
    errors: z.array(z.instanceof(Error)),
  }),
]);
const serializeError = (error: Error): { message: string } => ({
  message: error.message,
});
export const withComposable = (handler: ComposableRequestHandler) => {
  return async (
    req: Request,
    res: Response,
    _next: NextFunction,
  ): Promise<void> => {
    try {
      const result = await handler(req, res);
      const validationResult = ComposableResultSchema.safeParse(result);
      if (!validationResult.success) {
        res.status(500).json({
          success: false,
          errors: [
            serializeError(new Error('Invalid composable result format')),
          ],
        });
        return;
      }
      if (!result.success) {
        res.status(500).json({
          ...result,
          errors: result.errors.map(serializeError),
        });
        return;
      }
      res.json({
        ...result,
        errors: result.errors?.map(serializeError) ?? [],
      });
    } catch (error) {
      if (error instanceof Error) {
        res.status(500).json(serializeError(error));
      } else {
        res.status(500).json({
          message: 'An unknown error occurred',
        });
      }
    }
  };
};
</file>

<file path="src/routes/health.integration.test.ts">
import request from 'supertest';
import app from '../app';
describe('Health Check Endpoint', () => {
  it('should return a valid health check response', async () => {
    const response = await request(app).get('/health');
    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(response.body.data.status).toBe('ok');
    expect(new Date(response.body.data.timestamp)).toBeInstanceOf(Date);
  });
});
</file>

<file path="src/routes/health.ts">
import { Router } from 'express';
import { getHealthCheck } from '../use-cases/health/index';
import { withComposable } from '../middleware/composable';
const router = Router();
router.get(
  '/',
  withComposable((_req, _res) => getHealthCheck()),
);
export default router;
</file>

<file path="src/use-cases/health/index.test.ts">
import { describe, it, expect } from 'vitest';
import { getHealthCheck } from './index';
describe('getHealthCheck', () => {
  it('should return a valid health check response', async () => {
    const result = await getHealthCheck();
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.status).toBe('ok');
      expect(new Date(result.data.timestamp)).toBeInstanceOf(Date);
    }
  });
});
</file>

<file path="src/use-cases/health/index.ts">
import { composable } from 'composable-functions';
export const getHealthCheck = composable(
  () =>
    ({
      status: 'ok',
      timestamp: new Date().toISOString(),
    }) as const,
);
</file>

<file path="src/app.ts">
import express from 'express';
import healthRoutes from './routes/health';
const app = express();
app.use(express.json());
app.use('/health', healthRoutes);
export default app;
</file>

<file path="src/index.ts">
import app from './app';
import { config } from 'dotenv';
config();
const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
</file>

<file path=".eslintrc.json">
{
  "env": {
    "node": true,
    "es2022": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "prettier/prettier": "error",
    "@typescript-eslint/explicit-function-return-type": "error",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "@typescript-eslint/no-explicit-any": "error"
  }
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build
dist/

# Environment
.env

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE
.idea/
.vscode/
*.swp
*.swo

# Testing
coverage/

# OS
.DS_Store
Thumbs.db
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2
}
</file>

<file path="jest.config.js">
export default {
  preset: 'ts-jest',
  testEnvironment: 'node',
  extensionsToTreatAsEsm: ['.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  testMatch: ['**/*.integration.test.ts'],
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
      },
    ],
  },
  moduleDirectories: ['node_modules', 'src'],
};
</file>

<file path="package.json">
{
  "name": "face-recognition-api",
  "version": "1.0.0",
  "description": "A RESTful API for face recognition",
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "vitest run",
    "test:watch": "vitest watch",
    "test:integration": "jest --config jest.config.js",
    "format": "prettier --write \"src/**/*.ts\"",
    "lint": "eslint \"src/**/*.ts\" --fix",
    "prepare": "husky"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "composable-functions": "^4.5.0",
    "dotenv": "^16.4.1",
    "express": "^4.18.2",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.11",
    "@types/node": "^20.11.16",
    "@types/supertest": "^6.0.2",
    "@typescript-eslint/eslint-plugin": "^6.20.0",
    "@typescript-eslint/parser": "^6.20.0",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "husky": "^9.0.7",
    "jest": "^29.7.0",
    "prettier": "^3.2.4",
    "supertest": "^6.3.4",
    "ts-jest": "^29.1.2",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3",
    "vitest": "^1.2.2"
  }
}
</file>

<file path="README.md">
# Face Recognition API

A RESTful API for face recognition built with Node.js, TypeScript, and Express.

## Features

- TypeScript for type safety
- Express for routing
- Zod for runtime type validation
- Composable functions for functional programming
- Jest + Supertest for integration testing
- Vitest for unit testing
- ESLint + Prettier for code quality
- Husky for Git hooks

## Getting Started

### Prerequisites

- Node.js 18 or higher
- npm 7 or higher

### Installation

1. Clone the repository:

```bash
git clone https://github.com/yourusername/face-recognition-api.git
cd face-recognition-api
```

2. Install dependencies:

```bash
npm install
```

3. Create a `.env` file:

```bash
cp .env.sample .env
```

### Development

Start the development server:

```bash
npm run dev
```

### Testing

Run unit tests:

```bash
npm test
```

Run integration tests:

```bash
npm run test:integration
```

### Building

Build the project:

```bash
npm run build
```

Start the production server:

```bash
npm start
```

## API Documentation

### Health Check

```http
GET /health
```

Returns the health status of the API.

#### Response

```json
{
  "status": "ok",
  "timestamp": "2025-02-14T00:21:33.769Z"
}
```

## Project Structure

```
src/
├── functions/     # Pure functions and business logic
├── routes/        # Express route handlers
├── types/         # TypeScript type definitions
├── app.ts         # Express app setup
└── index.ts       # Application entry point
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the ISC License.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import path from 'path';
export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    exclude: ['**/*.integration.test.ts', 'node_modules'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
</file>

</files>
